module test_deriv
  use funit
  implicit none

  ! Explicit interface required as long as derivative functions
  ! are not defined in a module.
  interface
     subroutine derx_11(tx,ux,rx,sx,ffx,fsx,fwx,nx,ny,nz,npaire)
       integer :: nx,ny,nz,npaire
       real, dimension(nx,ny,nz) :: tx,ux,rx
       real, dimension(ny,nz):: sx
       real, dimension(nx):: ffx,fsx,fwx
     end subroutine derx_11
  end interface

  interface
     subroutine derx_00(tx,ux,rx,sx,ffx,fsx,fwx,nx,ny,nz,npaire)
       integer :: nx,ny,nz,npaire
       real, dimension(nx,ny,nz) :: tx,ux,rx
       real, dimension(ny,nz):: sx
       real, dimension(nx):: ffx,fsx,fwx
     end subroutine derx_00
  end interface

  enum, bind(c)
     enumerator :: periodic
     enumerator :: neumann
     enumerator :: dirichlet
  end enum

  @testParameter
  type, extends(AbstractTestParameter) :: pencilSize
     integer :: nx, ny, nz
   contains
     procedure :: toString
   end type pencilSize

   @testCase(testParameters={getParameters()}, constructor=newTestDeriv)
   type, extends(ParameterizedTestCase) :: testDeriv
      type(pencilSize) :: pencil_size
      real, allocatable, dimension(:, :, :) :: func, dfunc, expected_dfunc
      real, allocatable :: ff(:), fs(:), fw(:)
      real, allocatable :: s(:, :), di1(:, :, :)
    contains
      procedure :: allocate_on_pencil
      procedure :: setup_coefficient_arrays
      procedure :: setUp
      procedure :: tearDown
   end type testDeriv

 contains

   subroutine setUp(this)
     class(testDeriv), intent(inout) :: this

    call this % allocate_on_pencil(this % func)
    call this % allocate_on_pencil(this % dfunc)
    call this % allocate_on_pencil(this % expected_dfunc)
    call this % allocate_on_pencil(this % di1)
    allocate(this % s(this % pencil_size % ny, this % pencil_size % nz))

  end subroutine setUp

  subroutine tearDown(this)
    class(testDeriv), intent(inout) :: this

    deallocate(this % func, this % dfunc, this % expected_dfunc)
    deallocate(this % ff, this % fs, this % fw, this % s, this %di1)

   end subroutine tearDown

   function newTestDeriv(param)
     type(testDeriv) :: newTestDeriv
     type(pencilSize), intent(in) :: param
     newTestDeriv%pencil_size = param
   end function newTestDeriv

   function getParameters() result(test_pencil_sizes)
     type(pencilSize), allocatable :: test_pencil_sizes(:)
     test_pencil_sizes = [ &
          & pencilSize(16,16,16), &
          & pencilSize(32,32,32), &
          & pencilSize(64,64,64) &
          & ]
   end function getParameters

   subroutine allocate_on_pencil(this, array)
     class(testDeriv), intent(in) :: this
     real, allocatable, intent(inout) :: array(:, :, :)
     allocate(array( &
          & this % pencil_size % nx, &
          & this % pencil_size % ny, &
          & this % pencil_size % nz) &
          & )
   end subroutine allocate_on_pencil

   subroutine setup_coefficient_arrays(this, ff, fs, fw, ncl1, ncln)
     class(testDeriv), intent(in) :: this
     integer, intent(in) :: ncl1, ncln
     real, allocatable, intent(out) :: ff(:), fs(:), fw(:)

     real, allocatable :: fb(:)
     real, parameter :: alfai = 1. / 3.
     integer :: i

     ff = [(alfai, i = 1,this % pencil_size % nx)]
     fw = [(1., i = 1,this % pencil_size % nx)]
     fs = [(0., i = 1,this % pencil_size % nx)]
     fb = [(alfai, i = 1, this % pencil_size % nx)]

     ff(this % pencil_size % nx) = 0.
     fb(this % pencil_size % nx) = 0.

     select case(ncl1)
     case(neumann)
        ff(1) = alfai + alfai
     case(periodic)
        fw(1) = 2.
     case default
        write(*, *) "Shouldn't be here, stopping"
        stop
     end select

     select case(ncln)
     case(neumann)
        fb(this % pencil_size % nx - 1) = alfai + alfai
     case(periodic)
        fw(this % pencil_size % nx) = 1. + alfai * alfai
     case default
        write(*, *) "Shouldn't be here, stopping"
        stop
     end select

     do i=2,this % pencil_size % nx
        fs(i) = fb(i-1) / fw(i-1)
        fw(i) = fw(i) - ff(i-1) * fs(i)
     enddo
     fs(1) = 0.
     do i=1,this % pencil_size % nx
        fw(i) = 1. / fw(i)
     enddo

     deallocate(fb)
   end subroutine setup_coefficient_arrays

   function toString(this) result(string)
     class(pencilSize), intent(in) :: this
     character(:), allocatable :: string
     character(len=80) :: buffer
     write(buffer, '("nx = ",i3.3,1x,"ny = ( ",i3.3,1x,"nz = ( ",i3.3)')
     string = trim(buffer)
   end function toString

  @test
  subroutine test_derx_odd_11(this)
    use param, only: pi
    use derivX, only: afix, bfix

    class (testDeriv), intent(inout) :: this
    integer :: i, j, k
    real :: x, dx

    call this % setup_coefficient_arrays(this % ff, this % fs, this % fw, ncl1 = neumann, ncln = neumann)

    dx = 1. / (this % pencil_size % nx - 1)
    do k=1,this % pencil_size % nz
       do j=1,this % pencil_size % ny
          do i=1,this % pencil_size % nx
             x = (i - 1.) * dx * 4. * pi
             this % func(i,j,k) = sin(x)  !odd
             this % expected_dfunc(i,j,k) = 4. * pi * cos(x)
          enddo
       enddo
    enddo

    afix = (7. / 9.) / dx
    bfix = (1. / 36.) / dx
    call derx_11(this % dfunc, this % func, this % di1, &
         & this % s, this % ff, this % fs, this % fw, &
         & this % pencil_size % nx, &
         & this % pencil_size % ny, &
         & this % pencil_size % nz, npaire = 0)

    @assertEqual(this % dfunc, this % expected_dfunc, tolerance=1E-2)

  end subroutine test_derx_odd_11

  @test
  subroutine test_derx_odd_00(this)
    use param, only: pi
    use derivX, only: afix, bfix

    class (testDeriv), intent(inout) :: this

    integer :: i, j, k
    real :: x, dx

    call this % setup_coefficient_arrays(this % ff, this % fs, this % fw, ncl1 = periodic, ncln = periodic)

    dx = 1. / this % pencil_size % nx
    do k=1,this % pencil_size % nz
       do j=1,this % pencil_size % ny
          do i=1,this % pencil_size % nx
             x = (i - 1.) * dx * 4. * pi
             this % func(i,j,k) = sin(x)  !odd
             this % expected_dfunc(i,j,k) = 4. * pi * cos(x)
          enddo
       enddo
    enddo

    afix = (7. / 9.) / dx
    bfix = (1. / 36.) / dx
    call derx_00(this % dfunc, this % func, this % di1, &
         & this % s, this % ff, this % fs, this % fw, &
         & this % pencil_size % nx, &
         & this % pencil_size % ny, &
         & this % pencil_size % nz, npaire = 0)

    @assertEqual(this % dfunc, this % expected_dfunc, tolerance=1E-2)

  end subroutine test_derx_odd_00

end module test_deriv
